<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>KeyFolio Quiz</title>

    <!-- Bootstrap 5 -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />

    <!-- DataTables + Bootstrap 5 styling -->
    <link
      href="https://cdn.datatables.net/2.0.8/css/dataTables.bootstrap5.min.css"
      rel="stylesheet"
    />

    <style>
      body {
        padding: 24px;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }
      .choice-btn {
        text-align: left;
        white-space: normal;
      }
      .hidden {
        display: none;
      }
    </style>
  </head>

  <body>
    <div class="container-fluid">
      <div class="d-flex align-items-center justify-content-between mb-3">
        <div>
          <h3 class="mb-0">KeyFolio Quiz</h3>
          <div class="text-muted small mono" id="datasetMeta">Loading…</div>
        </div>
        <div class="d-flex gap-2">
          <button class="btn btn-outline-secondary btn-sm" id="btnReset">
            Reset Session
          </button>
          <button
            class="btn btn-outline-primary btn-sm"
            id="btnResume"
            disabled
          >
            Resume
          </button>
          <button class="btn btn-primary btn-sm" id="btnStart" disabled>
            Start New
          </button>
        </div>
      </div>

      <div class="row g-3">
        <div class="col-lg-7">
          <div class="card shadow-sm">
            <div class="card-body">
              <div class="d-flex justify-content-between align-items-start">
                <div>
                  <div class="badge text-bg-dark mb-2" id="phaseBadge">
                    Phase: —
                  </div>
                  <div class="text-muted small">Progress</div>
                  <div class="mono" id="progressLine">—</div>
                </div>
                <div class="text-end">
                  <div class="text-muted small">Score</div>
                  <div class="mono fw-bold" id="scoreLine">—</div>
                </div>
              </div>

              <hr />

              <div id="questionArea" class="hidden">
                <div class="text-muted small mb-1 mono" id="qIdLine">—</div>
                <h5 id="qPrompt" class="mb-3">—</h5>

                <div id="choicesArea" class="d-grid gap-2 mb-3"></div>

                <div class="d-flex gap-2">
                  <button class="btn btn-success" id="btnSubmit" disabled>
                    Submit
                  </button>
                  <button class="btn btn-primary hidden" id="btnNext">
                    Next
                  </button>
                  <button
                    class="btn btn-outline-secondary"
                    id="btnSkip"
                    title="Skips without answering (still stays in queue)"
                  >
                    Skip
                  </button>
                </div>

                <div class="mt-3">
                  <div id="feedback" class="alert hidden" role="alert"></div>
                </div>
              </div>

              <div id="doneArea" class="hidden">
                <div class="alert alert-success">
                  <div class="fw-bold">Quiz complete.</div>
                  <div class="mono" id="doneSummary">—</div>
                </div>
                <div class="d-flex gap-2">
                  <button class="btn btn-primary" id="btnShowResults">
                    Show Results Table
                  </button>
                  <button class="btn btn-outline-secondary" id="btnStartOver">
                    Start Over
                  </button>
                </div>
              </div>

              <div id="loadingArea">
                <div class="text-muted">Loading quiz database…</div>
              </div>
            </div>
          </div>
        </div>

        <div class="col-lg-5">
          <div class="card shadow-sm">
            <div class="card-body">
              <h6 class="mb-2">Session Notes</h6>
              <ul class="mb-0 small">
                <li>Question and choice order are randomized per session.</li>
                <li>
                  Answers are saved in
                  <span class="mono">sessionStorage</span> (clears when browser
                  tab closes).
                </li>
                <li>Missed questions get re-asked at the end until correct.</li>
              </ul>
              <hr />
              <div class="small text-muted mono" id="storageKeyLine">—</div>
            </div>
          </div>

          <div class="card shadow-sm mt-3 hidden" id="resultsCard">
            <div class="card-body">
              <h6 class="mb-3">Results</h6>
              <div class="table-responsive">
                <table
                  id="resultsTable"
                  class="table table-striped table-bordered w-100"
                >
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Prompt</th>
                      <th>Type</th>
                      <th>Attempts</th>
                      <th>Correct</th>
                      <th>Your Answer</th>
                      <th>Correct Answer</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
              <div class="mt-2 small text-muted">
                Tip: you can sort/search this table like a spreadsheet.
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- jQuery (DataTables depends on it) -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- DataTables -->
    <script src="https://cdn.datatables.net/2.0.8/js/dataTables.min.js"></script>
    <script src="https://cdn.datatables.net/2.0.8/js/dataTables.bootstrap5.min.js"></script>

    <script>
      (() => {
        // -----------------------------
        // Helpers
        // -----------------------------
        const shuffle = (arr) => {
          const a = arr.slice();
          for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
          }
          return a;
        };

        const deepClone = (obj) => JSON.parse(JSON.stringify(obj));

        const normalizeAnswer = (q, selectedChoiceIds) => {
          if (q.type === "single") return selectedChoiceIds?.[0] ?? null;
          return (selectedChoiceIds || []).slice().sort().join(",");
        };

        const correctAnswerNorm = (q) => {
          if (q.type === "single") return q.answer.choiceId;
          return q.answer.choiceIds.slice().sort().join(",");
        };

        const isCorrect = (q, selectedChoiceIds) =>
          normalizeAnswer(q, selectedChoiceIds) === correctAnswerNorm(q);

        // -----------------------------
        // Behavior Config
        // -----------------------------
        const AUTO_ADVANCE_MS_ON_CORRECT = 1000; // <-- change this anytime

        // -----------------------------
        // State + Storage
        // -----------------------------
        let db = null;
        let state = null; // persisted in sessionStorage
        let resultsTable = null;
        let lockQuestion = false; // prevents double-submit / changes after answer
        let pendingAdvanceTimer = null;
        let lastWasCorrect = null; // null | true | false

        const getStorageKey = () =>
          `KeyFolio.Quiz::${db?.datasetId || "unknown"}`;

        const loadState = () => {
          if (!db) return null;
          const raw = sessionStorage.getItem(getStorageKey());
          return raw ? JSON.parse(raw) : null;
        };

        const saveState = () => {
          sessionStorage.setItem(getStorageKey(), JSON.stringify(state));
          $("#storageKeyLine").text(`sessionStorage key: ${getStorageKey()}`);
        };

        const clearState = () => {
          if (!db) return;
          sessionStorage.removeItem(getStorageKey());
        };

        const newState = () => {
          const questions = deepClone(db.questions);

          // Randomize question order (store IDs)
          const mainOrder = shuffle(questions.map((q) => q.id));

          return {
            datasetId: db.datasetId,
            createdAt: new Date().toISOString(),
            phase: "main", // "main" | "retry" | "done"
            mainOrder,
            retryQueue: [], // question IDs missed this round
            cursor: 0, // index into current phase list
            currentOrder: mainOrder, // points to mainOrder or retryQueue (built later)
            selected: {}, // questionId -> { attempts, lastSelectedIds[], correct, history[] }
            score: { correct: 0, total: questions.length },
          };
        };

        // -----------------------------
        // UI bindings
        // -----------------------------
        const ui = {
          setMeta() {
            $("#datasetMeta").text(
              `${db.title} | datasetId=${db.datasetId} | v${db.version} | ${db.createdAt}`
            );
            $("#storageKeyLine").text(`sessionStorage key: ${getStorageKey()}`);
          },
          setControls() {
            const existing = loadState();
            $("#btnResume").prop("disabled", !existing);
            $("#btnStart").prop("disabled", false);
          },
          setPhaseBadge() {
            const phase = state?.phase || "—";
            const map = {
              main: "text-bg-primary",
              retry: "text-bg-warning",
              done: "text-bg-success",
            };
            $("#phaseBadge")
              .attr("class", `badge ${map[phase] || "text-bg-dark"} mb-2`)
              .text(`Phase: ${phase}`);
          },
          setProgress() {
            const totalMain = state.mainOrder.length;
            const phase = state.phase;
            const order = state.currentOrder || [];
            const pos = Math.min(state.cursor + 1, order.length);
            const total = order.length;

            const missed = state.retryQueue.length;

            $("#progressLine").text(
              phase === "main"
                ? `Main: ${Math.min(
                    state.cursor,
                    total
                  )} / ${totalMain} | Missed queued: ${missed}`
                : phase === "retry"
                ? `Retry: ${Math.min(
                    state.cursor,
                    total
                  )} / ${total} | Still missed: ${missed}`
                : `Done`
            );

            const correctCount = Object.values(state.selected).filter(
              (x) => x.correct
            ).length;
            $("#scoreLine").text(`${correctCount} / ${state.score.total}`);
          },
          showQuestion() {
            $("#loadingArea").addClass("hidden");
            $("#doneArea").addClass("hidden");
            $("#questionArea").removeClass("hidden");
            $("#resultsCard").addClass("hidden");

            // reset per-question UI
            $("#btnSubmit").prop("disabled", true);
            $("#btnNext").addClass("hidden");
            $("#btnSkip").prop("disabled", false);

            $("#feedback")
              .addClass("hidden")
              .removeClass("alert-success alert-danger alert-info")
              .text("");

            // reset per-question engine flags
            lockQuestion = false;
            lastWasCorrect = null;

            if (pendingAdvanceTimer) {
              clearTimeout(pendingAdvanceTimer);
              pendingAdvanceTimer = null;
            }
          },

          showDone() {
            $("#questionArea").addClass("hidden");
            $("#doneArea").removeClass("hidden");
            $("#loadingArea").addClass("hidden");
            ui.setProgress();
            ui.setPhaseBadge();

            const correctCount = Object.values(state.selected).filter(
              (x) => x.correct
            ).length;
            $("#doneSummary").text(
              `Final: ${correctCount}/${state.score.total} correct. Session stored until tab closes.`
            );
          },
        };

        // -----------------------------
        // Quiz engine
        // -----------------------------
        const getQuestionById = (id) => db.questions.find((q) => q.id === id);

        const ensurePhaseOrder = () => {
          if (state.phase === "main") {
            state.currentOrder = state.mainOrder;
            return;
          }

          if (state.phase === "retry") {
            // If retry queue is empty, we're done
            if (!state.retryQueue.length) {
              state.phase = "done";
              state.currentOrder = [];
              state.cursor = 0;
              return;
            }
            // Randomize the missed questions for the retry round
            state.currentOrder = shuffle(state.retryQueue);
            state.retryQueue = []; // will be repopulated if missed again
            state.cursor = 0;
            return;
          }
        };

        const renderCurrent = () => {
          ui.setPhaseBadge();
          ui.setProgress();

          if (state.phase === "done") {
            saveState();
            ui.showDone();
            return;
          }

          ensurePhaseOrder();

          if (state.phase === "done") {
            saveState();
            ui.showDone();
            return;
          }

          // If we've exhausted the current order, move phases
          if (state.cursor >= state.currentOrder.length) {
            if (state.phase === "main") {
              state.phase = "retry";
              ensurePhaseOrder();
            } else if (state.phase === "retry") {
              // if retryQueue was repopulated during retry, we loop another retry phase
              state.phase = "retry";
              ensurePhaseOrder();
            }
            saveState();
            return renderCurrent();
          }

          const qid = state.currentOrder[state.cursor];
          const q = deepClone(getQuestionById(qid));

          $("#btnSubmit").toggleClass("hidden", q.type === "single");

          // Randomize choice order each time shown (kept simple)
          q.choices = shuffle(q.choices);

          $("#qIdLine").text(
            `${q.id} • type=${q.type} • difficulty=${q.difficulty}`
          );
          $("#qPrompt").text(q.prompt);

          // Render choices as buttons + radio/checkbox
          const $choices = $("#choicesArea").empty();

          const inputName = "choiceGroup";
          q.choices.forEach((ch) => {
            const inputId = `ch_${qid}_${ch.id}_${Math.random()
              .toString(16)
              .slice(2)}`;
            const isMulti = q.type === "multi";

            const $wrap = $(`
        <div class="border rounded p-2">
          <div class="form-check">
            <input class="form-check-input" type="${
              isMulti ? "checkbox" : "radio"
            }" name="${inputName}" id="${inputId}" value="${ch.id}">
            <label class="form-check-label choice-btn w-100" for="${inputId}">
              <span class="mono">${ch.id}</span> — ${ch.text}
            </label>
          </div>
        </div>
      `);

            $choices.append($wrap);
          });

          // Enable submit when something selected.
          // For SINGLE questions: auto-submit immediately upon selection.
          // For MULTI questions: enable Submit when any is checked.
          $choices.off("change").on("change", "input", () => {
            if (lockQuestion) return;

            const any = $("#choicesArea input:checked").length > 0;
            $("#btnSubmit").prop("disabled", !any);

            if (q.type === "single" && any) {
              submitAnswer(); // auto-submit
            }
          });

          ui.showQuestion();
          saveState();
        };

        const submitAnswer = () => {
          if (lockQuestion) return;

          const qid = state.currentOrder[state.cursor];
          const q = getQuestionById(qid);

          const selectedIds = $("#choicesArea input:checked")
            .map((_, el) => el.value)
            .get();
          if (!selectedIds.length) return;

          // lock the question immediately to prevent double-submit
          lockQuestion = true;
          $("#btnSubmit").prop("disabled", true);
          $("#btnSkip").prop("disabled", true);
          $("#choicesArea input").prop("disabled", true);

          const entry = state.selected[qid] || {
            attempts: 0,
            lastSelectedIds: [],
            correct: false,
            history: [],
          };
          entry.attempts += 1;
          entry.lastSelectedIds = selectedIds.slice();
          entry.history.push({
            at: new Date().toISOString(),
            selectedIds: selectedIds.slice(),
          });

          const ok = isCorrect(q, selectedIds);
          entry.correct = ok;
          state.selected[qid] = entry;

          // If wrong, queue for end-of-quiz retry
          if (!ok) {
            state.retryQueue.push(qid);
          }

          // Feedback (stays)
          const $fb = $("#feedback").removeClass(
            "hidden alert-success alert-danger alert-info"
          );
          if (ok) {
            lastWasCorrect = true;
            $fb.addClass("alert-success").text("Correct.");
          } else {
            lastWasCorrect = false;
            $fb
              .addClass("alert-danger")
              .text(`Wrong answer. (${q.explanation})`);
          }

          const advanceToNext = () => {
            // Move to next question
            state.cursor += 1;
            saveState();
            renderCurrent();
          };

          saveState();

          // Advance behavior:
          // - Correct: auto-move after configured delay
          // - Wrong: show Next button, wait for user click
          if (ok) {
            pendingAdvanceTimer = setTimeout(() => {
              pendingAdvanceTimer = null;
              advanceToNext();
            }, AUTO_ADVANCE_MS_ON_CORRECT);
          } else {
            $("#btnNext").removeClass("hidden");
          }
        };

        const skipQuestion = () => {
          // Skipping keeps it in rotation by placing it into retry queue
          const qid = state.currentOrder[state.cursor];
          state.retryQueue.push(qid);
          state.cursor += 1;
          saveState();
          renderCurrent();
        };

        // -----------------------------
        // Results table
        // -----------------------------
        const showResults = () => {
          $("#resultsCard").removeClass("hidden");

          const rows = db.questions.map((q) => {
            const entry = state.selected[q.id] || {
              attempts: 0,
              lastSelectedIds: [],
              correct: false,
            };
            const yourNorm =
              q.type === "single"
                ? entry.lastSelectedIds?.[0] || ""
                : (entry.lastSelectedIds || []).slice().sort().join(",");

            const correctNorm =
              q.type === "single"
                ? q.answer.choiceId
                : q.answer.choiceIds.slice().sort().join(",");

            return {
              id: q.id,
              prompt: q.prompt,
              type: q.type,
              attempts: entry.attempts || 0,
              correct: entry.correct ? "YES" : "NO",
              your: yourNorm,
              correctAnswer: correctNorm,
            };
          });

          const $tbody = $("#resultsTable tbody").empty();
          rows.forEach((r) => {
            $tbody.append(`
        <tr>
          <td class="mono">${r.id}</td>
          <td>${escapeHtml(r.prompt)}</td>
          <td class="mono">${r.type}</td>
          <td class="mono">${r.attempts}</td>
          <td class="mono">${r.correct}</td>
          <td class="mono">${escapeHtml(r.your)}</td>
          <td class="mono">${escapeHtml(r.correctAnswer)}</td>
        </tr>
      `);
          });

          if (resultsTable) {
            resultsTable.destroy();
            resultsTable = null;
          }

          resultsTable = new DataTable("#resultsTable", {
            pageLength: 10,
            order: [[0, "asc"]],
            autoWidth: false,
          });
        };

        const escapeHtml = (s) =>
          (s || "")
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");

        // -----------------------------
        // Boot
        // -----------------------------
        const bindButtons = () => {
          $("#btnNext").on("click", () => {
            if (lockQuestion && lastWasCorrect === false) {
              advanceToNext();
            }
          });

          $("#btnReset").on("click", () => {
            if (!db) return;
            clearState();
            state = null;
            $("#btnResume").prop("disabled", true);
            $("#btnStart").prop("disabled", false);
            $("#resultsCard").addClass("hidden");
            $("#doneArea").addClass("hidden");
            $("#questionArea").addClass("hidden");
            $("#loadingArea")
              .removeClass("hidden")
              .text("Session cleared. Click Start New.");
          });

          $("#btnStart").on("click", () => {
            state = newState();
            saveState();
            renderCurrent();
          });

          $("#btnResume").on("click", () => {
            const existing = loadState();
            if (!existing) return;
            state = existing;
            renderCurrent();
          });

          $("#btnSubmit").on("click", submitAnswer);
          $("#btnSkip").on("click", skipQuestion);

          $("#btnShowResults").on("click", showResults);
          $("#btnStartOver").on("click", () => {
            clearState();
            state = newState();
            saveState();
            renderCurrent();
          });
        };

        const loadDb = async () => {
          const resp = await fetch("./QuizDB.json", { cache: "no-store" });
          if (!resp.ok)
            throw new Error(`Failed to load QuizDB.json (${resp.status})`);
          return await resp.json();
        };

        const init = async () => {
          bindButtons();

          try {
            db = await loadDb();
            ui.setMeta();
            ui.setControls();

            const existing = loadState();
            if (existing) {
              $("#loadingArea").text(
                "Found an existing session. Click Resume, or Start New."
              );
            } else {
              $("#loadingArea").text("Ready. Click Start New.");
            }

            $("#btnStart").prop("disabled", false);
            $("#btnResume").prop("disabled", !existing);
          } catch (e) {
            $("#loadingArea").text(
              "Failed to load QuizDB.json. Are you serving this folder via a web server?"
            );
            console.error(e);
          }
        };

        init();
      })();
    </script>
  </body>
</html>
